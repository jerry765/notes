> 汇编语言（第四版） 王爽著

机器指令：0/1组成
机器语言：机器指令的集合
**不同的微处理器可有不同的机器语言**

寄存器：CPU中可以存储数据的器件
存储器：向CPU提供要运行和处理的数据（**CPU不能直接和磁盘交换数据，必须由内存来交换**）

**指令和数据在形式上完全相同，都是一组二进制信息**

- 位bit：计算机的最小进制单位，即一位二进制数（0/1）
- 字节Byte：1Byte=8bit
**一个存储单元可以存储一个字节即8bit信息**

CPU传送地址/控制/数据信息
地址线N，地址总线宽度为N，可寻址2的N次方存储单元。
数据线N一次可传送N个bit的数据。
控制总线宽度决定CPU对外部器件控制能力。

AX 累加器。BX 基址。CX 计数器。DX 数据（通用寄存器）
SP 堆栈指针。BP 基数指针。SI 源变址。DI 目的变址。
IP 指令指针。
CS 代码段。DS 数据段。SS 堆栈段。ES 附加段。
**当通用寄存器作为8位寄存器使用时相当于两个独立寄存器，不产生进位**

物理地址=段地址✖️16+偏移地址=段地址（左移4/1位）+偏移地址
**一个数据二进制形式左移N位相当于数据乘以2的N次方**

一个段的起始地址一定是16的倍数（即XXXX0H），偏移地址为16位，所以一个段的长度最大为64KB

CS：IP SS：SP **CS IP不允许直接赋值**
jmp 段地址：偏移地址

**任意时刻，SS：SP指向栈顶地址**

常用[BX]提供内存单元的偏移地址，通过修改BX的值，可由DS：[BX]来寻址不同地址的内存单元

0:200——0:300安全

DW——字型数据。DB——字节型数据。DD——双字数据

AND——使指定位数置0
OR——使指定位数置1
大写二进制第三位0，小写第三位1

寻址：BX+SI/DI BP+SI/DI
结构体：[bx].idata
数组：idata[si],idata[di]
二维数组：[bx][idata],[bx][si]
表格（结构）中数组项[bx].idata[si]
二维数组：idata[bx][si]

div op
被除数16位：AX 除数8位：OP
被除数32位：DX高16位，AX低16位 除数16位：OP
结果
- 8位除数：商AL，余数AH
- 16位除数：商AX，余数DX
**被除数长度必须是除数长度两倍**

dup；重复变量伪指令

jmp
段内转移
- 只需修改IP的值
- 转移目的地址由JMP指令到目的地的偏移量决定
- 偏移量为8位或16位的带符号数

段间转移
- 同时修改CS IP
- 偏移量由段地址和偏移地址构成

JCXZ  CX=0转移到标号处执行

call
- push ip/push cs push ip
- 修改当前ip/ip cs指向目的地址
- call 标号 ip压栈
- call far ptr cs.ip压栈
- call reg ip压栈，用寄存器中的值修改ip
- call word(dword) ptr [内存]

ret pop ip
retf pop ip pop cs

标号：
       指令
       Ret

Mul reg

标志位符号
- ZF零标志位：运算结果是否为0
- PF奇偶标志位：运算结果低8位中1是否为偶数个
- SF符号标志位：运算结果是否为负
- CF进位标志位：是否有进位
- OF溢出标志位：是否溢出
- DF方向标志位：是否为减方向

带进位加法adc 带借位减法sbb

cmp比较指令：比较两者大小，只影响标志位不影响内容
- OP1=OP2 ZF=1
- 操作数无符号（不会溢出OF=0）
	- CF=0 OP1>OP2
	- CF=1 OP1<OP2
- 操作数有符号
	- OP12符号相同（不会溢出OF=0）
		- SF=0 OP1>OP2
		- SF=1 OP1<OP2
	- OP12符号不相同（有可能溢出）
		- OF=0
			- SF=0 OP1>OP2
			- SF=1 OP1<OP2
		- OF=1
			- SF=0 OP1<OP2
			- SF=1 OP1>OP2

**OF=SF时OP1>OP2，否则OP1<OP2**

条件转移
- JE 等于则转移 ZF=1
- JNE 不等于则转移 ZF=0
- JB 低于则转移 CF=1
- JNB 不低于则转移 CF=0
- JA 高于则转移 CF=0且ZF=0
- JNA 不高于则转移 CF=1或ZF=1

- Rep 重复执行相当于loop，用CX决定次数
- CLD 将DF置0
- STD 将DF置1

- pushf 将标志寄存器中的值压栈
- popf 从栈中弹出数据送入标志寄存器中

iret指令:
pop ip pop cs popf

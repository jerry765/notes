算法是对计算机上执行的**计算过程的具体描述**
性质
- **输入**：有零个或多个外部量作为算法的输入
- **输出**：算法产生至少一个量作为输出
- **确定性**：组成算法的每条指令清晰、无歧义
- **有限性**：算法中每条指令的执行次数有限，执行每条指令的时间也有限（**程序可以不满足有限性**）
- **能行性**

算法与数据结构的关系
- 算法是数据结构的**灵魂**
- 数据结构则是算法的**基础**
**算法＋数据结构＝程序**

正确性
- 定义：在给定**有效**输入后，算法经过**有限**时间的计算并产生**正确**的答案，就称算法是正确的

工作量——时间复杂性分析
- 计量工作量的标准: 对于给定问题，该算法所执行的**基本运算的次数**
- 基本运算的选择：根据问题选择适当的基本运算

占用空间——空间复杂性分析
- 两种占用
    - **存储程序和输入数据**的空间
    - 存储**中间结果或操作单元**所占用空间——额外空间
- 空间复杂性考虑的是**额外空间**的大小
- 如果额外空间相对于输入规模是常数，称为**原地工作的算法**

简单性
- 含义：算法简单，程序结构简单
- **简单的算法效率不一定高**
保证一定**效率**的前提下力求得到简单的算法

最优性
- 含义：指求解某类问题中**效率最高的算法**
- 两种最优性
    - 最坏情况：**最坏情况下的最优算法**
    - 平均情况：**平均情况下的最优算法**

解同一个问题，*算法不同，则计算的工作量也不同*，所需的计算时间随之不同，即复杂性不同

最优性：寻找最优算法的途径 (以**最坏情况下的最优性**
为例)
- 设计算法A，求W(n)。对问题给出**最坏情况下的一
个上界**。
- 寻找函数F(n)，使得对任何算法都存在一个规模为
n的输入并且该算法在这个输入下**至少要做F(n)次
基本运算**。
- 如果W(n)=F(n)，则A是最优的。
- 如果W(n)>F(n)，A不是最优的或者F(n)的下界过低。
    - 改进A或设计新算法A’使得W’(n)<W(n)。
    - 重新证明新下界F’(n)使得F’(n)>F(n)。
    - 重复以上两步，最终得到W’(n) = F’(n)为止

复杂性的计量
- **算法复杂性**是算法运行所需要的计算机资源的
量，需要时间资源的量称为**时间复杂性**，需要的空间资源的量称为**空间复杂性**
- 算法复杂性应该只依赖于算法要解的**问题的规模、算法的输入和算法本身的函数**

若出现**递归调用**，则上述由里向外逐层剥的分析**行不通：递归方程**，用**求递归方程解的渐进阶**的方法确定最坏情况下的复杂性的渐进阶

定理：
如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)
规模较小的问题,决定算法工作效率的可能是算法的简单性而不是算法执行的时间

递归的优势是表示某些定义非常自然，容易理解，但是会使*算法的时间复杂度大大提升，耗费更多的资源*
**边界条件**与**递归方程**是递归函数的两个要素

Hanoi塔问题
设 a,b,c 是 3 个塔座。开始时，在塔座 a 上有一叠共 n 个圆盘，这些圆盘自下而上，由大到
小地叠在一起。各圆盘从小到大编号为 1,2,…,n,现要求将塔座 a 上的这一叠圆盘移到塔座 c 上，并仍按同样顺序叠置。
在移动圆盘时应遵守以下移动规则：
（1）每次只能移动 1 个圆盘；
（2）任何时刻都不允许将较大的圆盘压在较小的圆盘之上；
（3）在满足移动规则 1 和 2 的前提下，可将圆盘移至 a,b,c 中任一塔座上。
``` java
public static void hanoi(int n,int a,int b,int c){
    if(n==1){
        move(a,c);
    }else if(n>1){
        hanoi(n-1,a,c,b);   //将n-1个盘子由a经过c移动到b
        move(a,c);  //执行最大盘子n移动
        hanoi(n-1,b,a,c);   //剩下的n-1个盘子由b经过a移动到c
    }
}
```

- 优点：结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法、调试程序带来很大方便
- 缺点：递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多
- 解决方法：在递归算法中**消除递归**调用，使其转化为非递归算法
    - 采用一个**用户定义的栈**来模拟系统的递归调用工作栈。该方法**通用性强**，但本质上还是递归，只不过人工做了本来由编译器做的事情，**优化效果不明显**
    - 用**递推**来实现递归函数

递推
- 递推算法是一种用**若干步可重复**的简单运算（规律）来描述复杂问题的方法
- 递推算法以初始{起点}值为基础，用相同的运算规律，逐次**重复运算**，直至运算结束
- 这种从“起点”重复相同的方法直至到达一定“边界”，犹如**单向运动**，用循环可以实现。递推的本质是按规律逐次推出（计算）下一步的结果

- **分治法的基本思想**
    1. 大问题分解为子问题，这些子问题互相独立且与原问题相同
    2. 分别**求解子问题**。如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止
    3. **合并**解，**自底向上**逐步求出原来问题的解
- 分治法的**设计思想**
    - 将一个难以直接解决的大问题，分割成一些**规模较小的相同**问题，以便各个击破，分而治之
- **分治法的适用条件**
    - 问题的**规模缩小**到一定的程度就可以容易地解决
    - 问题具有最优子结构性质（当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质）
    - 分解出的子问题的解可以**合并**为该问题的解
    - 问题所分解出的各个子问题是**相互独立**的，即子问题之间不包含公共的子问题
如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治法，但一般用**动态规划**较好

**分治法的基本步骤**
``` c
devide-and-conquer(P){
    if(|P|<=n0) adhoc(P);   //解决小规模的问题
    devide P into smaller sub_instances P1,P2...;
    for(int i=1;i<=k;i++)
        yi=devide-and-conquer(Pi);  //递归求解子问题

    return merge(y1,y2...); //合并
}
```

*在用分治法设计算法时，最好使子问题的规模大致相同*
